## 预备知识

### 1.2 Intel X86 CPU 系列的寻址方式

#### 四个段寄存器的由来

Intel 想在 8086 中采用 1M 字节的内存地址空间，而 8086 的 CPU 是 16 位的，也就是 ALU 的宽度是 16 位的，也就是 **数据总线** 是 16 位的。

一般 **地址总线** 的宽度最好是跟 **数据总线** 一致。因为从程序设计的角度来说，一个地址，也就是一个指针最好是与一个整数的长度一致。

那么现在想要 1M 的内存地址空间，也就是需要 **地址总线** 的宽度是 20 位才能满足这个寻址。

所以 Intel 在 CPU 中设置了四个段寄存器分别用于可执行代码

- CS：指令
- DS：数据
- SS：堆栈
- ES：其他

每个段寄存器都是 16 位的，对应于地址总线的高 16 位。每条“访问内存”指令中的“内部地址”都是 16 位的，但是在送上地址总线之前都在 CPU 内部自动的与段寄存器中的内容相加，形成一个 20 位的实际地址。

例：
C S:            1111 1111 1111 0000
内部地址:            0000 0000 0000 0001
实际地址:  1111 1111 1111 0000 0001

8086 这种内存寻址缺乏对内存空间的保护，所以称为 **实地址模式**。

为什么缺乏对内存空间的保护？因为可以用来改变段寄存器内容的指令不是什么 **“特权指令”**，任意一个进程都可以修改。

---

然鹅不久后，32位的 80386 CPU 开发成功了，为了实现 **保护模式**，同时与前面的段寄存器风格保持一致，又新增了两个段寄存器 FS、GS。