# 数据结构与算法



## 6. 递归
1. 汉诺塔

2. 归并排序  O(N*logN)
缺点：需要在存储器中有另一个大小等于被排序的数据项目的数组。如果初始数组几乎占满整个存储器，那么归并排序将不能工作。

## 7. 高级排序
> 选择排序、快速排序、希尔排序、堆排序**不是稳定**的排序算法。
> 冒泡排序、插入排序、基数排序、归并排序**是稳定**的排序算法。

1. 希尔排序 O(N^3/2 ~ N^7/6)
希尔排序是基于插入排序的。 由于插入排序中，一个很小的数据在很靠近右端的位置上时，会造成大量的不必要的移动，所以导致效率很慢，如果数据项能大跨度地移动就好了。希尔排序则是根据这个点的优化。

2. 快速排序  O(N*logN)


## 8. 二叉树
1. 二叉树：每个节点最多有两个子节点。
2. 二叉搜索树：一个节点的左子节点的关键字值小于这个父节点，右子节点的关键字值大于等于这个父节点。（**本节讨论的都是基于二叉搜索树**）
3. 非平衡树：大部分的节点在根的一边或者是另一边，就可以说它是不平衡的。
4. 树的遍历
 - 前序
```
private void preOrder(Node localRoot) {
	if(localRoot != null) {
    	System.out.println(localRoot.iData + " ");
    	inOrder(localRoot.leftChild);
        inOrder(localRoot.rightChild);
    }
}
```
 - 中序
中序遍历二叉搜索树会使所有的节点**按关键字升序**被访问到。
```
private void inOrder(Node localRoot) {
	if(localRoot != null) {
    	inOrder(localRoot.leftChild);
        System.out.println(localRoot.iData + " ");
        inOrder(localRoot.rightChild);
    }
}
```

 - 后序
```
private void postOrder(Node localRoot) {
	if(localRoot != null) {
    	inOrder(localRoot.leftChild);
        inOrder(localRoot.rightChild);
         System.out.println(localRoot.iData + " ");
    }
}
```

5. 用数组表示树
找节点的 子节点和父节点 可以利用简单的算术计算他们在数组中的索引值。
假设 节点索引值为 $$$index$$$
则节点的左子节点是 $$$2*index + 1$$$
则节点的右子节点是 $$$2*index + 2$$$
它的父节点是     $$$(index - 1) / 2$$$


## 9. 红 - 黑树
1. 二叉搜索树
 - 普通的二叉搜索树作为数据存储工具有重要的优势：可以快速找到一个给定关键字的数据项，并且可以快速的插入和删除数据项。
 - 缺点：当插入的数据是有序的数据时（无论是升序还是逆序），速度就变得特别慢。因为当插入数值有序时，二叉树就是非平衡的了，而对于非平衡数，它的快速查找（插入、删除）指定数据项的能力就丧失了。

2. 解决非平衡树问题的方法之一： **红 - 黑树**，它是增加了某些特点的二叉搜索树。
3. 搜索部分非平衡树的时间介于 O(N) 和 O(log N)，这取决于树的不平衡程度。

4. **红 - 黑树特征**
 - 节点都有颜色。(实际就是在节点类中增加一个数据字段，可以是boolean型的(例 isRed)，以此来表示颜色的信息)
 - 在插入和删除的过程中，要遵循保持这些颜色的不同排列的规则。
 - 红黑规则： 
 	- 每一个节点不是红色的就是黑色的。
 	- 根总是黑色的。
 	- 如果节点是红色的，则它的子节点必须是黑色的（反之倒不一定必须为真）。
 	- 从根到叶节点或空子节点的每条路径，必须包含相同数目的黑色节点。
 - 修正违规的情况：假设颜色的规则被违犯了，如何进行修正
 	- 改变节点的颜色。
 	- 执行旋转操作。 












