# 数据结构与算法



## 6. 递归

1. 汉诺塔

2. 归并排序  O(N*logN)
缺点：需要在存储器中有另一个大小等于被排序的数据项目的数组。如果初始数组几乎占满整个存储器，那么归并排序将不能工作。



## 7. 高级排序

> 选择排序、快速排序、希尔排序、堆排序**不是稳定**的排序算法。

> 冒泡排序、插入排序、基数排序、归并排序**是稳定**的排序算法。

> **排序的稳定性**是指：存在多个具有相同排序码的记录， 排序后这些记录的相对次序保持不变。
> 例如：
> 排序前：**34**, 12, **34'**, 08, 96
> 排序后：08, 12, **34**, **34'**, 96
> 我们就说这个排序是稳定的




1. 希尔排序 O(N^3/2 ~ N^7/6)
希尔排序是基于插入排序的。 由于插入排序中，一个很小的数据在很靠近右端的位置上时，会造成大量的不必要的移动，所以导致效率很慢，如果数据项能大跨度地移动就好了。希尔排序则是根据这个点的优化。

2. 快速排序  O(N*logN)





## 8. 二叉树

1. 二叉树：每个节点最多有两个子节点。

2. 二叉搜索树：一个节点的左子节点的关键字值小于这个父节点，右子节点的关键字值大于等于这个父节点。（**本节讨论的都是基于二叉搜索树**）

3. 非平衡树：大部分的节点在根的一边或者是另一边，就可以说它是不平衡的。
4. 叶节点：没有子节点的节点称为 “叶节点”

4. 树的遍历 (每种遍历都有**递归**和**循环**两个不同的实现方式)

 - 前序

```

private void preOrder(Node localRoot) {

	if(localRoot != null) {

    	System.out.println(localRoot.iData + " ");

    	inOrder(localRoot.leftChild);

        inOrder(localRoot.rightChild);

    }

}

```

 - 中序

中序遍历二叉搜索树会使所有的节点**按关键字升序**被访问到。

```

private void inOrder(Node localRoot) {

	if(localRoot != null) {

    	inOrder(localRoot.leftChild);

        System.out.println(localRoot.iData + " ");

        inOrder(localRoot.rightChild);

    }

}

```



 - 后序

```

private void postOrder(Node localRoot) {

	if(localRoot != null) {

    	inOrder(localRoot.leftChild);

        inOrder(localRoot.rightChild);

         System.out.println(localRoot.iData + " ");

    }

}

```



5. 用数组表示树

找节点的 子节点和父节点 可以利用简单的算术计算他们在数组中的索引值。

假设 节点索引值为 $$$index$$$

则节点的左子节点是 $$$2*index + 1$$$

则节点的右子节点是 $$$2*index + 2$$$

它的父节点是     $$$(index - 1) / 2$$$





## 9. 红 - 黑树

1. 二叉搜索树

 - 普通的二叉搜索树作为数据存储工具有重要的优势：可以快速找到一个给定关键字的数据项，并且可以快速的插入和删除数据项。

 - 缺点：当插入的数据是有序的数据时（无论是升序还是逆序），速度就变得特别慢。因为当插入数值有序时，二叉树就是非平衡的了，而对于非平衡数，它的快速查找（插入、删除）指定数据项的能力就丧失了。

2. 解决非平衡树问题的方法之一： **红 - 黑树**，它是增加了某些特点的二叉搜索树。

3. 搜索部分非平衡树的时间介于 O(N) 和 O(log N)，这取决于树的不平衡程度。

4. **红 - 黑树特征**

 - 节点都有颜色。(实际就是在节点类中增加一个数据字段，可以是boolean型的(例 isRed)，以此来表示颜色的信息)

 - 在插入和删除的过程中，要遵循保持这些颜色的不同排列的规则。

 - 红黑规则： 

 	- 每一个节点不是红色的就是黑色的。

 	- 根总是黑色的。

 	- 如果节点是红色的，则它的子节点必须是黑色的（反之倒不一定必须为真）。

 	- 从根到叶节点或空子节点的每条路径，必须包含相同数目的黑色节点。

 - 修正违规的情况：假设颜色的规则被违犯了，如何进行修正

 	- 改变节点的颜色。

 	- 执行旋转操作。 

5. 旋转
 - 使一些节点上升，一些节点下降，帮助树平衡。

 - 保证不破坏二叉搜索树的特征。

 - **简单旋转:**  选择一个节点作为旋转的 “顶端”(top)。 如果做一次右旋，这个 “顶端” 节点将会向下和向右移动到它的右子节点的位置。它的左子节点将会上移到它原来的位置上。 *(做右旋，顶端节点必须要有一个左子节点；做左旋，顶端节点必须要有一个右子节点)*

 - 旋转之奇异的横向移动 : 节点 A 为顶端节点的内侧子孙节点，如果 A 是上移节点*( 在右旋中是顶端节点的左子节点 )*的子节点，那么 A 总是要断开和父节点的连接并且重新连接到它以前的祖父节点上。


## 10. 2-3-4 树和外部存储
1. 多叉树( multiway tree) : 允许每个节点可以有更多的数据项和更多的子节点。

2. 2-3-4 树就是多叉树 : 它的每个节点最多有四个子节点和三个数据项。它像 红黑树 一样是平衡树，它的效率比红黑树稍差，但编程容易。

3. 在2-3-4树中，不允许只有一个链接。有一个数据项的节点必须总是保持有两个连接，除非它是叶节点，在那种情况下没有链接。
















