## Binder 机制初探

`Read The Fucking Source Code`

由于初学 Binder 机制，所以 Binder 系列只是本人浅薄的理解，如有不正确的地方，还请指正。

### 0. 准备工作

首先问自己几个问题：
- 为什么要跨进程通信（IPC）？ （进程之间是不可以通信的吗）
- 怎么做到跨进程通信？   （怎样用常规的方式在两个进程之间进行通信呢）
- 为什么是 Binder ？    （为什么常规的跨进程方式不行，而要专门使用 Binder）

回答这几个问题，我们得先了解一下几个概念。为后面做铺垫。

Android 系统是基于 Linux 内核的，因此有必要了解一些相关知识。

#### 0.1 进程隔离

> 进程隔离是为保护操作系统中进程互不干扰而设计的一组不同硬件和软件的技术。这个技术是为了避免 进程A 写入 进程B 的情况发生。 进程的隔离实现，使用了虚拟地址空间。进程A 的虚拟地址和 进程B 的虚拟地址不同，这样就防止 进程A 将数据信息写入 进程B。

以上来自维基百科：进程隔离的安全性通过禁止进程间内存的访问可以方便实现。相比之下，一些不安全的操作系统（例如DOS）能够允许任何进程对其他进程的内存进行写操作。

根据以上描述，我们可以知道 操作系统的不同进程之间，数据是不共享的，即禁止进程间内存的访问。因此我们可以回答第一个问题。
**Q：为什么要跨进程通信**
**A：根据上述可以得知，进场之间是不可以进行通信的，所以我们需要有某种方式来完成 跨进程通信。**

#### 0.2 用户空间 / 内核空间

详细解释可参考 [Kernel Space Definition](http://www.linfo.org/kernel_space.html)

Linux 系统内存可以分为两个不同的区域：**内核空间**和**用户空间**。 
内核空间是内核（即操作系统的核心）执行（即运行）并提供其服务的地方。
用户空间是指 用户进程（即内核以外的所有内容）运行的内存位置集。

Linux Kernel 是操作系统的核心，独立于普通的应用程序，可以访问受保护的内存空间，也有访问底层硬件设备的所有权限。 内核的一个角色是管理这个空间中的各个用户进程，并防止它们相互干扰。
对于Kernel这么一个高安全级别的东西，显然是不容许其它的应用程序随便调用或访问的，所以需要对Kernel提供一定的保护机制，这个保护机制用来告诉那些应用程序，你只可以访问某些许可的资源，不许可的资源是拒绝被访问的，于是就把Kernel和上层的应用程序抽像的隔离开，分别称之为Kernel Space和User Space。

简单理解就是：
内核空间可以执行任意命令，调用系统的一切资源;
用户空间只能执行简单的运算，不能直接调用系统资源；
那么用户空间肯定会有想 调用系统资源 的需求，比如应用程序访问文件的等。

根据 [Kernel Space Definition](http://www.linfo.org/kernel_space.html) 这篇文字的详细说明，我们可以得知：
> Kernel space can be accessed by user processes only through the use of system calls. 
> 只有通过使用**系统调用**，用户进程才能访问内核空间。

#### 0.3 系统调用 / 内核态 / 用户态

用户空间访问内核空间的唯一方式就是 **系统调用**；通过这个统一入口接口，所有的资源访问都是在内核的控制下执行，以免导致用户程序对系统资源的越权访问，从而保障了系统的安全和稳定。用户软件良莠不齐，要是它们乱搞把系统玩坏了怎么办？因此对于某些特权操作必须交给安全可靠的内核来执行。

当一个任务（进程）执行系统调用而陷入内核代码中执行时，我们就称进程处于**内核运行态（或简称为内核态**）此时处理器处于特权级最高的（0级）内核代码中执行。当进程在执行用户自己的代码时，则称其处于**用户运行态（用户态）**。即此时处理器在特权级最低的（3级）用户代码中运行。处理器在特权等级高的时候才能执行那些特权CPU指令。


#### 0.4 内存映射 之 mmap 方法
https://www.cnblogs.com/huxiao-tee/p/4660352.html#_label0
mmap 是 内存映射文件 的一种方法。即将一个文件或者其它对象映射到进程的地址空间。实现文件磁盘地址和进程虚拟地址空间中一段虚拟地址的一一对应关系。

Linux 内核使用一个 vm_area_struct 结构体来表示一个独立的虚拟内存区域。
vm_area_struct 内包含一个 vm_ops 指针，其内部可引出所有针对这个区域可以使用的系统调用函数。
mmap 函数就是要创建一个新的 vm_area_struct 结构体，并将其与文件的物理磁盘地址相连。

总而言之，常规文件操作需要从磁盘到页缓存（处于内核空间）再到用户主存的两次数据拷贝。而mmap操控文件，只需要从磁盘到用户主存的一次数据拷贝过程。


##### 具体的分析可查看如下文章
[Gityuan Binder 系列](http://gityuan.com/2015/10/31/binder-prepare/)
[Binder 学习指南](http://weishu.me/2016/01/12/binder-index-for-newer/)
[Android 接口定义语言 (AIDL)](https://developer.android.com/guide/components/aidl?hl=zh-cn)
[老罗的 Android 之旅](https://blog.csdn.net/luoshengyang/article/details/6618363)
[Android Bander设计与实现 - 设计篇](https://blog.csdn.net/universus/article/details/6211589)
[相见恨晚 Binder 机制](https://blog.csdn.net/freekiteyu/article/details/70082302)


