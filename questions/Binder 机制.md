## Binder 机制初探

`Read The Fucking Source Code`

### 0. 准备工作

首先问自己几个问题：
- 为什么要跨进程通信（IPC）？ （进程之间是不可以通信的吗）
- 怎么做到跨进程通信？   （怎样用常规的方式在两个进程之间进行通信呢）
- 为什么是 Binder ？    （为什么常规的跨进程方式不行，而要专门使用 Binder）

回答这几个问题，我们得先了解一下几个概念。为后面做铺垫。

Android 系统是基于 Linux 内核的，因此有必要了解一些相关知识。

#### 0.1 进程隔离

> 进程隔离是为保护操作系统中进程互不干扰而设计的一组不同硬件和软件的技术。这个技术是为了避免 进程A 写入 进程B 的情况发生。 进程的隔离实现，使用了虚拟地址空间。进程A 的虚拟地址和 进程B 的虚拟地址不同，这样就防止 进程A 将数据信息写入 进程B。

以上来自维基百科：进程隔离的安全性通过禁止进程间内存的访问可以方便实现。相比之下，一些不安全的操作系统（例如DOS）能够允许任何进程对其他进程的内存进行写操作。

根据以上描述，我们可以知道 操作系统的不同进程之间，数据是不共享的，即禁止进程间内存的访问。因此我们可以回答第一个问题。
**Q：为什么要跨进程通信**
**A：根据上述可以得知，进场之间是不可以进行通信的，所以我们需要有某种方式来完成 跨进程通信。**

#### 0.2 用户空间 / 内核空间

详细解释可参考 [Kernel Space Definition](http://www.linfo.org/kernel_space.html)

Linux 系统内存可以分为两个不同的区域：**内核空间**和**用户空间**。 
内核空间是内核（即操作系统的核心）执行（即运行）并提供其服务的地方。
用户空间是指 用户进程（即内核以外的所有内容）运行的内存位置集。

Linux Kernel 是操作系统的核心，独立于普通的应用程序，可以访问受保护的内存空间，也有访问底层硬件设备的所有权限。 内核的一个角色是管理这个空间中的各个用户进程，并防止它们相互干扰。
对于Kernel这么一个高安全级别的东西，显然是不容许其它的应用程序随便调用或访问的，所以需要对Kernel提供一定的保护机制，这个保护机制用来告诉那些应用程序，你只可以访问某些许可的资源，不许可的资源是拒绝被访问的，于是就把Kernel和上层的应用程序抽像的隔离开，分别称之为Kernel Space和User Space。

简单理解就是：
内核空间可以执行任意命令，调用系统的一切资源;
用户空间只能执行简单的运算，不能直接调用系统资源；
那么用户空间肯定会有想 调用系统资源 的需求，比如应用程序访问文件的等。

根据 [Kernel Space Definition](http://www.linfo.org/kernel_space.html) 这篇文字的详细说明，我们可以得知：
> Kernel space can be accessed by user processes only through the use of system calls. 
> 只有通过使用**系统调用**，用户进程才能访问内核空间。

#### 0.3 系统调用 / 内核态 / 用户态

用户空间访问内核空间的唯一方式就是 **系统调用**；通过这个统一入口接口，所有的资源访问都是在内核的控制下执行，以免导致用户程序对系统资源的越权访问，从而保障了系统的安全和稳定。用户软件良莠不齐，要是它们乱搞把系统玩坏了怎么办？因此对于某些特权操作必须交给安全可靠的内核来执行。

当一个任务（进程）执行系统调用而陷入内核代码中执行时，我们就称进程处于**内核运行态（或简称为内核态**）此时处理器处于特权级最高的（0级）内核代码中执行。当进程在执行用户自己的代码时，则称其处于**用户运行态（用户态）**。即此时处理器在特权级最低的（3级）用户代码中运行。处理器在特权等级高的时候才能执行那些特权CPU指令。





##### 参考
http://weishu.me/2016/01/12/binder-index-for-newer/
https://developer.android.com/guide/components/aidl?hl=zh-cn
https://blog.csdn.net/luoshengyang/article/details/6618363
https://blog.csdn.net/universus/article/details/6211589


